# Define the User class
class User:
    def __init__(self, user_id, name, birth_date, gender, location, interests, constellation, mbti, smoking, drinking, profession, height, bio,  # Initial users' attributes
                 liked_users=None, disliked_users=None,
                 matches=None):  # A list of user IDs that this user has liked/disliked/matched. It defaults to an empty list now.
        self.user_id = user_id
        self.name = name
        self.birth_date = birth_date
        self.gender = gender
        self.location = location
        self.interests = interests
        self.constellation = constellation
        self.mbti = mbti
        self.smoking = smoking
        self.drinking = drinking
        self.profession = profession
        self.height = height
        self.bio = bio
        # might not be empty if existing user (future)
        self.liked_users = liked_users if liked_users is not None else []
        self.disliked_users = disliked_users if disliked_users is not None else []
        self.matches = matches if matches is not None else []

    def like(self, other_user):
        if other_user.user_id not in self.liked_users:  # Check other user whether in my liked list
            self.liked_users.append(other_user.user_id)  # If not,then add in other user list
        if self.user_id in other_user.liked_users and other_user.user_id not in self.matches:  # Check whether other user's liked lists had me, if it is, then matched
            self.matches.append(other_user.user_id)  # After matched, both sided added user id in match list
            other_user.matches.append(self.user_id)

    def dislike(self, other_user):
        if other_user.user_id not in self.disliked_users:  # If other user id not in my disliked list
            self.disliked_users.append(other_user.user_id)  # Then add the other user id in my list

    def __review__(self):  # Fastly show user full profile .
        return (f'User({self.user_id}, {self.name}, {self.birth_date}, {self.gender}, '
                f'{self.location}, {self.interests}, {self.constellation},{self.mbti},{self.smoking},{self.drinking},{self.profession},{self.height},{self.bio},{self.liked_users}, '
                f'{self.disliked_users}, {self.matches})')

        import sqlite3

def setup_database():
    db_file = 'users.db'
    # If DB exists - delete it upon setup:
    if os.path.exists(db_file):
        os.remove(db_file)
        print(f"Deleted existing database file: {db_file}")

    # Create a connection to the SQLite database
    conn = sqlite3.connect(db_file)
    cursor = conn.cursor()

    # Create a table for storing user information with new columns
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            name TEXT,
            birth_date INTEGER,
            gender TEXT,
            location TEXT,
            interests TEXT,
            constellation TEXT,
            mbti TEXT,
            smoking TEXT,
            drinking TEXT,
            profession TEXT,
            height REAL,
            bio TEXT,
            liked_users TEXT,
            disliked_users TEXT,
            matches TEXT
        )
    ''')

    # Commit changes and close the connection
    conn.commit()
    conn.close()

def insert_user(user):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()

    # Convert lists to comma-separated strings for storage
    liked_users = ','.join(map(str, user.liked_users))
    disliked_users = ','.join(map(str, user.disliked_users))
    matches = ','.join(map(str, user.matches))

    cursor.execute('''
        INSERT INTO users (user_id, name, birth_date, gender, location, interests, constellation, mbti, smoking, drinking, profession, height, bio, liked_users, disliked_users, matches)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (user.user_id, user.name, user.birth_date, user.gender, user.location,
          ','.join(user.interests), user.constellation, user.mbti, user.smoking, user.drinking,
          user.profession, user.height, user.bio, liked_users, disliked_users, matches))

    conn.commit()
    conn.close()

def delete_user(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()

    # First, update other users' liked_users, disliked_users, and matches lists to remove this user
    cursor.execute('SELECT * FROM users')
    all_users = cursor.fetchall()

    for user_data in all_users:
        current_user_id, name, birth_date, gender, location, interests, constellation, mbti, smoking, drinking, profession, height, bio, liked_users, disliked_users, matches = user_data

        liked_users_list = list(map(int, liked_users.split(','))) if liked_users else []
        disliked_users_list = list(map(int, disliked_users.split(','))) if disliked_users else []
        matches_list = list(map(int, matches.split(','))) if matches else []

        if user_id in liked_users_list:
            liked_users_list.remove(user_id)
        if user_id in disliked_users_list:
            disliked_users_list.remove(user_id)
        if user_id in matches_list:
            matches_list.remove(user_id)

        # Update the current user with the modified lists
        liked_users = ','.join(map(str, liked_users_list))
        disliked_users = ','.join(map(str, disliked_users_list))
        matches = ','.join(map(str, matches_list))

        cursor.execute('''
            UPDATE users
            SET liked_users = ?, disliked_users = ?, matches = ?
            WHERE user_id = ?
        ''', (liked_users, disliked_users, matches, current_user_id))

    # Now delete the user from the database
    cursor.execute('DELETE FROM users WHERE user_id = ?', (user_id,))

    conn.commit()
    conn.close()

def update_user(user):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()

    liked_users = ','.join(map(str, user.liked_users))
    disliked_users = ','.join(map(str, user.disliked_users))
    matches = ','.join(map(str, user.matches))

    cursor.execute('''
        UPDATE users
        SET name = ?, birth_date = ?, gender = ?, location = ?, interests = ?, constellation = ?, mbti = ?, smoking = ?, drinking = ?, profession = ?, height = ?, bio = ?, liked_users = ?, disliked_users = ?, matches = ?
        WHERE user_id = ?
    ''', (user.name, user.birth_date, user.gender, user.location,
          ','.join(user.interests), user.constellation, user.mbti, user.smoking, user.drinking,
          user.profession, user.height, user.bio, liked_users, disliked_users, matches, user.user_id))

    conn.commit()
    conn.close()

def fetch_user(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()

    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user_data = cursor.fetchone()

    conn.close()

    if user_data:
        user_id, name, birth_date, gender, location, interests, constellation, mbti, smoking, drinking, profession, height, bio, liked_users, disliked_users, matches = user_data

        # Convert comma-separated strings back to lists
        interests = interests.split(',')
        liked_users = list(map(int, liked_users.split(','))) if liked_users else []
        disliked_users = list(map(int, disliked_users.split(','))) if disliked_users else []
        matches = list(map(int, matches.split(','))) if matches else []

        return User(user_id, name, birth_date, gender, location, interests, constellation, mbti, smoking, drinking, profession, height, bio, liked_users, disliked_users, matches)
    else:
        return None  # User not found
        import pandas as pd
import numpy as np
import sqlite3

# Assuming the User class is already defined as provided.

# Load All Users into a Pandas DataFrame
def fetch_all_users():
    conn = sqlite3.connect('users.db')
    df = pd.read_sql_query("SELECT * FROM users", conn)
    conn.close()

    # Convert each comma-separated string in the 'interests' column to a list of interests
    df['interests'] = df['interests'].apply(lambda x: x.split(',') if x else [])

    # Ensure smoking and drinking columns are present
    df['smoking'] = df['smoking'].astype(str)  # Assuming smoking column has values like 'yes', 'no'
    df['drinking'] = df['drinking'].astype(str)  # Assuming drinking column has values like 'yes', 'no'

    return df

# Define MBTI compatibility score
mbti_pairs = {
    "ENFJ": ["INFP"],
    "ENTJ": ["INFP"],
    "INFJ": ["ENFP"],
    "INTJ": ["ENFP"],
    "ENTP": ["INFJ", "INTJ"],
    "ISFP": ["ENFJ", "ESFJ", "ESTJ"],
    "ISTP": ["ESTJ", "ESFJ"],
    "ESTJ": ["ISFP", "ISTP"],
    "ESFJ": ["ISFP", "ISTP"],
    "ISTJ": ["ESFP"],
    "ISFJ": ["ESFP"]
}

def get_mbti_score(mbti1, mbti2):
    preferred_matches = mbti_pairs.get(mbti1, [])
    return 1.0 if mbti2 in preferred_matches else 0.0

# Define the zodiac compatibility score
# Define the zodiac compatibility score
def get_zodiac_compatibility(zodiac1, zodiac2):
    zodiac_compatibility = {
        ('Aries', 'Aries'): 0.50,
        ('Aries', 'Taurus'): 0.38,
        ('Aries', 'Gemini'): 0.83,
        ('Aries', 'Cancer'): 0.42,
        ('Aries', 'Leo'): 0.97,
        ('Aries', 'Virgo'): 0.63,
        ('Aries', 'Libra'): 0.85,
        ('Aries', 'Scorpio'): 0.50,
        ('Aries', 'Sagittarius'): 0.93,
        ('Aries', 'Capricorn'): 0.47,
        ('Aries', 'Aquarius'): 0.78,
        ('Aries', 'Pisces'): 0.67,
        ('Taurus', 'Taurus'): 0.65,
        ('Taurus', 'Gemini'): 0.33,
        ('Taurus', 'Cancer'): 0.97,
        ('Taurus', 'Leo'): 0.73,
        ('Taurus', 'Virgo'): 0.90,
        ('Taurus', 'Libra'): 0.65,
        ('Taurus', 'Scorpio'): 0.88,
        ('Taurus', 'Sagittarius'): 0.30,
        ('Taurus', 'Capricorn'): 0.98,
        ('Taurus', 'Aquarius'): 0.58,
        ('Taurus', 'Pisces'): 0.85,
        ('Gemini', 'Gemini'): 0.60,
        ('Gemini', 'Cancer'): 0.65,
        ('Gemini', 'Leo'): 0.88,
        ('Gemini', 'Virgo'): 0.68,
        ('Gemini', 'Libra'): 0.93,
        ('Gemini', 'Scorpio'): 0.28,
        ('Gemini', 'Sagittarius'): 0.60,
        ('Gemini', 'Capricorn'): 0.68,
        ('Gemini', 'Aquarius'): 0.85,
        ('Gemini', 'Pisces'): 0.53,
        ('Cancer', 'Cancer'): 0.75,
        ('Cancer', 'Leo'): 0.35,
        ('Cancer', 'Virgo'): 0.90,
        ('Cancer', 'Libra'): 0.43,
        ('Cancer', 'Scorpio'): 0.94,
        ('Cancer', 'Sagittarius'): 0.53,
        ('Cancer', 'Capricorn'): 0.90,
        ('Cancer', 'Aquarius'): 0.27,
        ('Cancer', 'Pisces'): 0.98,
        ('Leo', 'Leo'): 0.45,
        ('Leo', 'Virgo'): 0.35,
        ('Leo', 'Libra'): 0.97,
        ('Leo', 'Scorpio'): 0.58,
        ('Leo', 'Sagittarius'): 0.97,
        ('Leo', 'Capricorn'): 0.58,
        ('Leo', 'Aquarius'): 0.35,
        ('Leo', 'Pisces'): 0.38,
        ('Virgo', 'Virgo'): 0.65,
        ('Virgo', 'Libra'): 0.68,
        ('Virgo', 'Scorpio'): 0.88,
        ('Virgo', 'Sagittarius'): 0.48,
        ('Virgo', 'Capricorn'): 0.95,
        ('Virgo', 'Aquarius'): 0.30,
        ('Virgo', 'Pisces'): 0.88,
        ('Libra', 'Libra'): 0.75,
        ('Libra', 'Scorpio'): 0.35,
        ('Libra', 'Sagittarius'): 0.73,
        ('Libra', 'Capricorn'): 0.55,
        ('Libra', 'Aquarius'): 0.90,
        ('Libra', 'Pisces'): 0.88,
        ('Scorpio', 'Scorpio'): 0.88,
        ('Scorpio', 'Sagittarius'): 0.35,
        ('Scorpio', 'Capricorn'): 0.95,
        ('Scorpio', 'Aquarius'): 0.28,
        ('Scorpio', 'Pisces'): 0.97,
        ('Sagittarius', 'Sagittarius'): 0.48,
        ('Sagittarius', 'Capricorn'): 0.60,
        ('Sagittarius', 'Aquarius'): 0.90,
        ('Sagittarius', 'Pisces'): 0.63,
        ('Capricorn', 'Capricorn'): 0.95,
        ('Capricorn', 'Aquarius'): 0.55,
        ('Capricorn', 'Pisces'): 0.88,
        ('Aquarius', 'Aquarius'): 0.68,
        ('Aquarius', 'Pisces'): 0.45,
        ('Pisces', 'Pisces'): 0.60,
    }

    # Ensure the score is for both directions
    return zodiac_compatibility.get((zodiac1, zodiac2),
                                    zodiac_compatibility.get((zodiac2, zodiac1), 0.0))

# Define smoking and drinking compatibility scores
def get_smoking_score(smoking1, smoking2):
    return 1.0 if smoking1 == smoking2 else 0.0

def get_drinking_score(drinking1, drinking2):
    return 1.0 if drinking1 == drinking2 else 0.0

# Compute Compatibility Scores
def compute_compatibility_scores(logged_in_user, users_df):
    # Exclude the logged-in user from potential matches
    potential_matches = users_df[users_df['user_id'] != logged_in_user.user_id].copy()

    # Calculate location compatibility score
    potential_matches['location_score'] = (potential_matches['location'] == logged_in_user.location).astype(float)

    # Calculate age difference score
    potential_matches['age_diff_score'] = 1 / (1 + np.abs(potential_matches['birth_date'] - logged_in_user.birth_date))

    # Calculate zodiac compatibility score
    potential_matches['zodiac_score'] = potential_matches.apply(
        lambda row: get_zodiac_compatibility(
            logged_in_user.zodiac_sign, logged_in_user.gender,
            row['zodiac_sign'], row['gender']
        ), axis=1
    )

    # Calculate MBTI compatibility score
    potential_matches['mbti_score'] = potential_matches.apply(
        lambda row: get_mbti_score(
            logged_in_user.mbti, row['mbti']
        ), axis=1
    )

    # Calculate smoking compatibility score
    potential_matches['smoking_score'] = potential_matches.apply(
        lambda row: get_smoking_score(
            logged_in_user.smoking, row['smoking']
        ), axis=1
    )

    # Calculate drinking compatibility score
    potential_matches['drinking_score'] = potential_matches.apply(
        lambda row: get_drinking_score(
            logged_in_user.drinking, row['drinking']
        ), axis=1
    )

    # Convert interests lists into a set for the logged-in user for faster comparison
    logged_in_interests_set = set(logged_in_user.interests)

    # Optimize shared interests score calculation
    def calculate_jaccard_similarity_vectorized(interests):
        interests_set = set(interests)
        intersection_size = len(logged_in_interests_set & interests_set)
        union_size = len(logged_in_interests_set | interests_set)
        return intersection_size / union_size if union_size > 0 else 0

    # Apply the vectorized Jaccard similarity calculation to all potential matches
    potential_matches['interests_score'] = potential_matches['interests'].apply(calculate_jaccard_similarity_vectorized)

    # Combine the individual scores into a final compatibility score
    potential_matches['compatibility_score'] = (
        0.25 * potential_matches['location_score'] +  # Adjusted weight for location score
        0.2 * potential_matches['age_diff_score'] +   # Adjusted weight for age score
        0.15 * potential_matches['zodiac_score'] +    # Zodiac score with its weight
        0.1 * potential_matches['mbti_score'] +       # MBTI score with its weight
        0.1 * potential_matches['smoking_score'] +    # Smoking score with its weight
        0.1 * potential_matches['drinking_score'] +   # Drinking score with its weight
        0.1 * potential_matches['interests_score']    # Interests score remains the same
    )

    # Sort by the compatibility score in descending order
    potential_matches = potential_matches.sort_values(by='compatibility_score', ascending=False)

    return potential_matches

# Rank the Potential Matches and Display the Top 5
def display_top_matches(potential_matches, top_n=5):
    top_matches = potential_matches[['user_id', 'name', 'location', 'age', 'compatibility_score']].head(top_n)
    print("Top Matches:")
    print(top_matches)
    return top_matches

# Select and Like a Match
def select_and_like_match(logged_in_user, selected_match_id):
    # Fetch the selected match as a User object
    selected_user = fetch_user(selected_match_id)
    # Use the User class's like method
    logged_in_user.like(selected_user)

    # Update both users in the database
    update_user(logged_in_user)
    update_user(selected_user)

# Update and Display the Logged-In User's Profile
def update_and_display_user_profile(logged_in_user):
    # Update the logged-in user's profile in the database
    update_user(logged_in_user)

    # Fetch and display the updated profile
    updated_user = fetch_user(logged_in_user.user_id)
    print("Updated User Profile:")
    print(vars(updated_user))

# Example Scenario
def scenario1():

    setup_database()

    # Create users
    user1 = User(1, 'Alice', "2001-06-03", 'F', 'New York', ['music', 'hiking', 'movies'],'Leo','ESTP','Always','Sometimes','Student','165','Just do it')
    user2 = User(2, 'Bob', "1997-07-05", 'M', 'San Francisco', ['sports', 'movies', 'traveling'],'Virgin','ISTP','Never','Never','student','180','I Love reading')
    user3 = User(3, 'Charlie', "1994-4-28", 'M', 'Chicago', ['cooking', 'gaming', 'technology'],'Gemini','INFP','Sometimes','Sometimes','student','175','Hello World')


    # Insert users into the database
    insert_user(user1)
    insert_user(user2)
    insert_user(user3)

    # Step 1: Fetch the logged-in user
    logged_in_user = fetch_user(1)  # Assume user_id=1, Alice, is the logged-in user
    print('Variables of the logged in user: ', vars(logged_in_user))

    # Step 2: Load all users into a DataFrame
    all_users_df = fetch_all_users()
    print('head of df:')
    print(all_users_df.head(3))
    # Step 3: Compute and rank top matches based on compatibility score
    potential_matches = compute_compatibility_scores(logged_in_user, all_users_df)

    # Step 4: Display the top 5 matches
    top_matches = display_top_matches(potential_matches)

    # Step 5: Select and like a match
    selected_match_id = int(top_matches.iloc[0]['user_id'])  # Assume the user selects the top match
    print('selected_match_id', selected_match_id)
    select_and_like_match(logged_in_user, selected_match_id)

    # Step 6: Update and display the logged-in user's profile
    update_and_display_user_profile(logged_in_user)

# Run the example scenario
scenario1()

